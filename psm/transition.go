package psm

import (
	"context"
	"fmt"

	"google.golang.org/protobuf/proto"
)

/*
# Generic Type Parameter Sets

Two sets of generic type sets exist:

`S ST E IE`
`S ST E IE SE`

Both share the same types, as follows

### `S IState[ST]`

The State Entity, implements IState[ST], e.g. *testpb.FooState

### `ST IStatusEnum`

The Status Enum of the state entity implements IStatusEnum,
e.g. *testpb.FooStatus (int32)

### `E IEvent[IE]`

The Event Wrapper, the top level which has metadata, foreign keys to the state, and the event itself.
e.g. *testpb.FooEvent, the concrete proto message

### `IE IInnerEvent`

The Inner Event, the typed event *interface* which is the set of all possible events for the state machine
e.g. testpb.FooPSMEvent interface - this is generated by the protoc plugin in _psm.pb.go
It is set at compile time specifically to the interface type.

### `SE IInnerEvent`

The Specific single typed event *struct* which is the specific event for the transition.
SE implements the same interface of IE.
e.g. *testpb.FooPSMEvent_Created, the concrete proto message which implements testpb.FooPSMEvent


The state machine deals with the first shorter chain, as it deals with all events.
Transitions deal with a single specific event type, so have the extra SE parameter.

S, ST, E, and IE are set to one single type for the entire state machine
SE is set to a single type for each transition.
*/

type IStatusEnum interface {
	~int32
	ShortString() string
}

type IState[Status IStatusEnum] interface {
	proto.Message
	GetStatus() Status
}

type IEvent[Inner any] interface {
	proto.Message
}

type IInnerEvent interface {
	proto.Message
}

type ITransition[
	S proto.Message,
	ST IStatusEnum,
	E IEvent[IE],
	IE IInnerEvent,
] interface {
	Matches(S, IE) bool
	RunTransition(context.Context, TransitionBaton[E, IE], S, IE) error
}

type Transition[
	S IState[ST],
	ST IStatusEnum,
	E IEvent[IE],
	IE IInnerEvent,
	SE IInnerEvent,
] struct {
	fromStatus  []ST
	eventFilter func(SE) bool
	transition  func(context.Context, TransitionBaton[E, IE], S, SE) error
}

func NewTransition[
	S IState[ST],
	ST IStatusEnum,
	E IEvent[IE],
	IE IInnerEvent,
	SE IInnerEvent,
](
	fromStatus []ST,
	transition func(context.Context, TransitionBaton[E, IE], S, SE) error,
) *Transition[S, ST, E, IE, SE] {
	return &Transition[S, ST, E, IE, SE]{
		fromStatus: fromStatus,
		transition: transition,
	}
}

func (ts *Transition[S, ST, E, IE, SE]) WithEventFilter(eventFilter func(SE) bool) *Transition[S, ST, E, IE, SE] {
	ts.eventFilter = eventFilter
	return ts
}

func (ts Transition[S, ST, E, ET, SE]) RunTransition(
	ctx context.Context,
	tb TransitionBaton[E, ET],
	state S,
	event ET,
) error {
	// Cast the interface ET IInnerEvent to the specific type of event which
	// this transition handles
	asType, ok := any(event).(SE)
	if !ok {
		return fmt.Errorf("unexpected event type: %T", event)
	}

	return ts.transition(ctx, tb, state, asType)
}

func (ts Transition[S, ST, E, IE, SE]) Matches(state S, event IE) bool {
	// Check if the parameter passed as ET (IInnerEvent) is the specific type
	// (IE, also IInnerEvent, but typed) which this transition handles
	asType, ok := any(event).(SE)
	if !ok {
		return false
	}
	didMatch := false

	if ts.fromStatus != nil {
		currentStatus := state.GetStatus()
		for _, fromStatus := range ts.fromStatus {
			if fromStatus == currentStatus {
				didMatch = true
				break
			}
		}
		if !didMatch {
			return false
		}
	}

	if ts.eventFilter != nil && !ts.eventFilter(asType) {
		return false
	}
	return true
}
