package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/pentops/protostate/gen/v1/psm_pb"
)

const version = "1.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-psm %v\n", version)
		return
	}

	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

type buildingStateSet struct {
	stateMessage *protogen.Message
	stateOptions *psm_pb.StateObjectOptions
	eventMessage *protogen.Message
	eventOptions *psm_pb.EventObjectOptions
}

// generateFile generates a _psm.pb.go
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {

	stateSets := make(map[string]*buildingStateSet)

	for _, message := range file.Messages {
		stateObjectAnnotation, ok := proto.GetExtension(message.Desc.Options(), psm_pb.E_State).(*psm_pb.StateObjectOptions)
		if ok && stateObjectAnnotation != nil {
			stateSet, ok := stateSets[stateObjectAnnotation.Name]
			if !ok {
				stateSet = &buildingStateSet{}
				stateSets[stateObjectAnnotation.Name] = stateSet
			} else if stateSet.stateMessage != nil || stateSet.stateOptions != nil {
				gen.Error(fmt.Errorf("duplicate state object name %s", stateObjectAnnotation.Name))
				continue
			}

			stateSet.stateMessage = message
			stateSet.stateOptions = stateObjectAnnotation
		}

		eventObjectAnnotation, ok := proto.GetExtension(message.Desc.Options(), psm_pb.E_Event).(*psm_pb.EventObjectOptions)
		if ok && eventObjectAnnotation != nil {
			ss, ok := stateSets[eventObjectAnnotation.Name]
			if !ok {
				ss = &buildingStateSet{}
				stateSets[eventObjectAnnotation.Name] = ss
			} else if ss.eventMessage != nil || ss.eventOptions != nil {
				gen.Error(fmt.Errorf("duplicate event object name %s", eventObjectAnnotation.Name))
				continue
			}

			ss.eventMessage = message
			ss.eventOptions = eventObjectAnnotation

		}
	}

	if len(stateSets) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_psm.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-psm. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, stateSet := range stateSets {
		converted, err := buildStateSet(stateSet)
		if err != nil {
			gen.Error(err)
			continue
		}
		if err := addStateSet(g, converted); err != nil {
			gen.Error(err)
		}
	}
	return g
}

type stateSet struct {
	namePrefix  string
	machineName string

	stateMessage *protogen.Message
	eventMessage *protogen.Message

	// Name of the inner event interface
	eventName string

	// In the Status message, this is the enum for the simplified status
	// is always an Enum
	statusFieldInState *protogen.Field

	// fields in which are the same in the state and the event, e.g. the PK
	eventStateKeyFields []eventStateFieldMap

	// field in the root of the outer event for the inner event oneof wrapper
	// is always a Message
	eventTypeField *protogen.Field

	// field in the root of the outer event for the event metadata
	metadataField *protogen.Field
}

type eventStateFieldMap struct {
	eventField *protogen.Field
	stateField *protogen.Field
}

func buildStateSet(src *buildingStateSet) (*stateSet, error) {
	ss := &stateSet{
		stateMessage: src.stateMessage,
		eventMessage: src.eventMessage,
	}
	ss.namePrefix = strings.TrimSuffix(src.stateMessage.GoIdent.GoName, "State")
	ss.machineName = ss.namePrefix + "PSM"
	ss.eventName = ss.namePrefix + "PSMEvent"

	for _, field := range src.stateMessage.Fields {
		fr := field.Desc
		if fr.Name() == "status" {
			ss.statusFieldInState = field
		}
	}

	if ss.statusFieldInState == nil {
		return nil, fmt.Errorf("state object %s does not have a state field", src.stateOptions.Name)
	}

	if ss.statusFieldInState.Enum == nil {
		return nil, fmt.Errorf("state object %s state field is not an enum", src.stateOptions.Name)
	}

	for _, field := range src.eventMessage.Fields {
		fieldOpt := proto.GetExtension(field.Desc.Options(), psm_pb.E_EventField).(*psm_pb.EventField)
		if fieldOpt == nil {
			continue
		}

		if fieldOpt.EventType {
			if field.Message == nil {
				return nil, fmt.Errorf("event object %s event type field is not a message", src.eventOptions.Name)
			}
			ss.eventTypeField = field
		} else if fieldOpt.Metadata {
			ss.metadataField = field
		} else if fieldOpt.StateKey {
			var matchingStateField *protogen.Field
			for _, stateField := range src.stateMessage.Fields {
				if stateField.Desc.Name() == field.Desc.Name() {
					matchingStateField = stateField
					break
				}
			}
			if matchingStateField == nil {
				return nil, fmt.Errorf("event object %s state key field %s does not exist in state object %s", src.eventOptions.Name, field.Desc.Name(), src.stateOptions.Name)
			}

			if matchingStateField.Desc.Kind() != field.Desc.Kind() {
				return nil, fmt.Errorf("event object %s state key field %s is not the same type as state object %s", src.eventOptions.Name, field.Desc.Name(), src.stateOptions.Name)
			}

			ss.eventStateKeyFields = append(ss.eventStateKeyFields, eventStateFieldMap{
				eventField: field,
				stateField: matchingStateField,
			})
		}

	}

	// the oneof wrapper
	if ss.eventTypeField == nil {
		return nil, fmt.Errorf("event object %s does not have an event type field", src.eventOptions.Name)
	}

	if ss.eventTypeField.Message == nil {
		return nil, fmt.Errorf("event object %s event type field is not a message", src.eventOptions.Name)
	}

	return ss, nil
}

func addStateSet(g *protogen.GeneratedFile, ss *stateSet) error {

	g.P("// StateObjectOptions: ", ss.machineName)

	sm := protogen.GoImportPath("github.com/pentops/protostate/psm")

	printTypes := func() {
		g.P("*", ss.stateMessage.GoIdent, ",")
		g.P(ss.statusFieldInState.Enum.GoIdent.GoName, ",")
		g.P("*", ss.eventMessage.GoIdent, ",")
		g.P(ss.eventName, ",")

	}

	g.P("type ", ss.machineName, " struct {")
	g.P("*", sm.Ident("Eventer"), "[")
	printTypes()
	g.P("]")
	g.P("}")
	g.P()
	g.P("type ", ss.machineName, "Spec = ", sm.Ident("StateSpec"), "[")
	printTypes()
	g.P("]")
	g.P()
	g.P("type ", ss.machineName, "TransitionBaton = ", sm.Ident("TransitionBaton"), "[", ss.eventName, "]")

	g.P()
	g.P("type ", ss.eventName, "Key string")
	g.P()
	g.P("const (")
	for _, field := range ss.eventTypeField.Message.Fields {
		g.P(ss.namePrefix, "PSMEvent", field.GoName, " ", ss.eventName, "Key = \"", field.Desc.Name(), "\"")
	}
	g.P(")")
	g.P()
	g.P("type ", ss.eventName, " interface {")
	g.P(protogen.GoImportPath("google.golang.org/protobuf/proto").Ident("Message"))
	g.P("PSMEventKey() ", ss.eventName, "Key")
	g.P("}")

	// Converting types

	g.P("type ", ss.machineName, "Converter struct {")
	g.P("Metadata ", ss.machineName, "EventMetadataConverter")
	g.P("}")
	g.P()

	g.P("type ", ss.eventName, "MetadataConverter interface {")
	g.P("  NewMetadata(", protogen.GoImportPath("context").Ident("Context"), ") *", ss.metadataField.Message.GoIdent)
	g.P("  ExtractMetadata(*", ss.metadataField.Message.GoIdent, ") *", sm.Ident("Metadata"))
	g.P("}")

	// eventStateKeyField is the a field in the event which comes from the state

	g.P("func(c *", ss.machineName, "Converter) Wrap(ctx ",
		protogen.GoImportPath("context").Ident("Context"),
		", s *", ss.stateMessage.GoIdent, ", e ", ss.eventName, ") *", ss.eventMessage.GoIdent, " {")
	g.P("wrapper := &", ss.eventMessage.GoIdent, "{")
	g.P(ss.metadataField.GoName, ": c.Metadata.NewMetadata(ctx),")
	// Copy all of the shared fields from State
	for _, field := range ss.eventStateKeyFields {
		g.P(field.eventField.GoName, ": s.", field.stateField.GoName, ",")
	}
	g.P("}")
	g.P("wrapper.SetPSMEvent(e)")
	g.P("return wrapper")
	g.P("}")
	g.P()
	g.P("func (c *", ss.machineName, "Converter) Unwrap(e *", ss.eventMessage.GoIdent, ") ", ss.eventName, " {")
	g.P("return e.UnwrapPSMEvent()")
	g.P("}")
	g.P()
	g.P("func (c *", ss.machineName, "Converter) StateLabel(s *", ss.stateMessage.GoIdent, ") string {")
	g.P("return s.Status.String()")
	g.P("}")
	g.P()
	g.P("func (c *", ss.machineName, "Converter) EventLabel(e ", ss.eventName, ") string {")
	g.P("return string(e.PSMEventKey())")
	g.P("}")
	g.P()
	g.P("func (c *", ss.machineName, "Converter) EventMetadata(e *", ss.eventMessage.GoIdent, ") *", sm.Ident("Metadata"), " {")
	g.P("return c.Metadata.ExtractMetadata(e.", ss.metadataField.GoName, ")")
	g.P("}")

	g.P("func (ee *", ss.eventMessage.GoIdent, ") UnwrapPSMEvent() ", ss.eventName, " {")
	g.P("	switch v := ee.", ss.eventTypeField.GoName, ".Type.(type) {")
	for _, field := range ss.eventTypeField.Message.Fields {
		g.P("	case *", field.GoIdent, ":")
		g.P("		return v.", field.GoName)
	}
	g.P("	default:")
	g.P("		return nil")
	g.P("	}")
	g.P("}")

	g.P("func (ee *", ss.eventMessage.GoIdent, ") SetPSMEvent(inner ", ss.eventName, ") {")
	g.P("	switch v := inner.(type) {")
	for _, field := range ss.eventTypeField.Message.Fields {
		g.P("	case *", field.Message.GoIdent, ":")
		g.P("		ee.", ss.eventTypeField.GoName, ".Type = &", field.GoIdent, "{", field.GoName, ": v}")
	}
	g.P("	default:")
	g.P("		panic(\"invalid type\")")
	g.P("	}")
	g.P("}")

	for _, field := range ss.eventTypeField.Message.Fields {
		g.P("func (*", field.Message.GoIdent, ") PSMEventKey() ", ss.eventName, "Key  {")
		g.P("		return ", ss.namePrefix, "PSMEvent", field.GoName)
		g.P("}")
	}
	g.P()

	return nil

}
